<!DOCTYPE html>
<html>

<head>
  
<link href="http://getbootstrap.com/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Optional Bootstrap Theme -->

<link href="data:text/css;charset=utf-8," data-href="http://getbootstrap.com/dist/css/bootstrap-theme.min.css" rel="stylesheet" id="bs-theme-stylesheet">

<!-- Documentation extras -->

<link href="http://getbootstrap.com/assets/css/docs.min.css" rel="stylesheet">

<!--[if lt IE 9]><script src="../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
<script src="http://getbootstrap.com/assets/js/ie-emulation-modes-warning.js"></script>

</head>

<body>
<div class="wrapper">

<header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand">Ninki</a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li>
          <a>Documentation</a>
        </li>
      </ul>
    </nav>
  </div>
</header>

    


<div class="container bs-docs-container">

<div class="row">
  
    <ul>
  <li>Authentication</li>
  <li>PGP Key Exchange</li>
  <li>Multi Signature Architecture</li>
  </ul>
</div>

<div class="row">

<div class="col-md-9">

<h2>Authentication</h2>

<p>
When the user creates an account a secret is shared between the server and the client. The client encrypts a randomly generated secret using their password as an input to a pbkdf along with a unique salt. The encryption scheme is AES 256 Mode: CBC, Padding: No Padding
</p>

<p>
The encrypted secret is stored on the server. When the user attempts to login to the server the entered password is derived to a passphrase using a unique salt. The client requests the encrypted secret from the server, the server returns the encrypted secret and the client decrypts using the passphrase. The result is sent back to the server and the server compares the secret with value originally shared.
</p>

<p>The user has 4 attempts to succesfully decrypt the secret before the account is locked. Once the user has proven that they can decrypt the secret, and therefore know the password, the server challenges them to provide a one time 2 factor authentication code. If this is validated succesfully the user is authenticated and a session token is issued.</p>

<p>The encrypted packet containing the users api key and public key information is sent to the client and decrypted using the passphrase. The client maintains a connection with the server polling every 10 seconds, if there is no communication for over 60 seconds, the session is timed out and the user will have to authenticate to establish a session.</p>



<h2>PGP Key Exchange</h2>

<h3>Rationale</h3>

<p>Bitcoin addresses are difficult to exchange and require either copying and pasting or qr code scanning. This promotes address re-use which in turn can make funds vunerable to R value attacks and are detrimental to financial privacy.</p>

<p>The PGP scheme described here removes the need for exchanging bitcoin addresses everytime two users transact, and promotes zero address re-use. After the PGP validation is complete it becomes less effort to generate new addreses on behalf of each other then it does to find the previous address used for that user and copy/paste it into a transaction.</p>

<p>The server can facilitate the initial exchange, but should not be trusted, and so an out of band validation is required. Note: this should also happen over a secure channel, however this is up to the user as we have, by definition no control over the choice of channel.</p>

<p>Finally, the addresses are generated by the client and not handed off from the server, removing the threat of the server handing off bad addresses. The server acts purely as a verification service, a cross check between what the client has generated and what the server expected.</p>

<p>This provides an extra layer of security against malware on the client replacing the address before the transaction is signed and sent to our server.</p>


<h3>PGP Key Exchange</h3>


<p>The wallet supports exchanging HD public ec key nodes with other users on the service. The purpose of this is to allow
users who regularly transact with each other, to generate addresses on each other's behalf. So instead of you sending
me an address, I simply derive one from the next node on the public key chain you assinged and sent to me.</p>

<p>This presents a problem of a MIM attack when exchanging these parent nodes. How do we know the server which is 
facilitating the exchange is not compromised.</p>

<p>To solve this we use PGP with the keys generated on the client at the time of account creation and stored in an
encrypted packet, using the user's passphrase.</p>

<p>An out of band fingerprint exchange must occur between the two users in order to validate that the service or another
actor has not compromised the integrity of the key exchange. We present this fingerprint in the form of a BIP39 encoded
mnemonic reffered to as a 'Ninki Phrase'.</p>


<h3>Alice provides a node to Bob</h3>


<img src="pgp-ex.png" />


<div class="bs-callout">
<ol>

<li>Bob's PGP public key is registered with the server, we can refer to this as an untrusted public key.</li>

<li>Alice retrieves the untrusted PGP public key for Bob from the server.</li>

<li>Alice encrypts her HD node with Bob's untrusted PGP public key and signs it with her PGP private key.</li>

<li>Alice encrypts Bob's untrusted PGP public key with her PGP public key and stores on the server for future reference.</p>

<li>Bob retrieves the packet encrypted by Alice from the server and decrypts using his PGP private key.</li>

<li>Bob retrieves Alice's untrusted PGP public key from the server and validates the signature on the packet matches.</li>

<li>Bob encrypts the contents of the packet and Alice's untrusted PGP public key with his PGP public key and stores on the server for future reference.</li>

<li>Out of band, Alice sends Bob her PGP public key fingerprint</li>

<li>Bob verifies that the untrusted PGP public key he has stored for Alice matches this fingerprint.</li>

<li>Alice's PGP public key is now trusted by Bob and the integrity of the exchange is verified.</li>

</ol>
  </div>
  
<p>
Whenever Bob needs to generate an address for Alice, he retrieves the packet from the server, decrypts it with his PGP private key and derives a new address for Alice. The reverse process happens and Alice and Bob now have connected wallets. 
</p>


<h2>Multi Signature Architecture</h2>


</div>


</div>
  
</div>
  
</div>
</body>
</html>
